{"version":3,"file":"state.js","sourceRoot":"","sources":["../src/state.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,6CAAuD;AACvD,uCAA8B;AAC9B,sDAA8B;AAE9B,oCAAoC;AACpC,iCAAiC;AACjC;IASI,MAAM,CAAC,IAAI,CAAC,UAAkB;QAC1B,IAAI,CAAC,KAAK,GAAG,IAAI,uBAAU,EAAE,CAAC;QAC9B,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QACpD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACvD,CAAC;IAED,MAAM,CAAC,eAAe,CAAC,GAAgB;QACnC,IAAI,CAAC,gBAAgB,CAAC,EAAE,EAAE,UAAU,EAAE;YAClC,IAAI,EAAE,GAAG,CAAC,IAAI;YACd,EAAE,EAAE,GAAG,CAAC,EAAE;YACV,MAAM,EAAE,GAAG,CAAC,MAAM;YAClB,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,SAAS,EAAE,GAAG,CAAC,SAAS;SAC3B,CAAC,CAAC;IACP,CAAC;IAEO,MAAM,CAAC,gBAAgB,CAAC,KAAa,EAAE,IAAY,EAAE,IAAS;QAClE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;YAC5B,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,EAAE;gBAC5B,OAAO,CAAC,GAAG,CAAC,sBAAsB,GAAG,IAAI,CAAC,CAAC;gBAC3C,MAAM;aACT;YAED,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;SACvD;IACL,CAAC;IAEO,MAAM,CAAO,eAAe,CAAC,CAAY,EAAE,IAAY,EAAE,IAAS;;YACtE,OAAO,IAAI,OAAO,CAAC,UAAS,OAAO,EAAE,MAAM;gBACvC,MAAM,IAAI,GAAG,CAAC,CAAC,OAAO,GAAG,GAAG,GAAG,IAAI,CAAC;gBAEpC,iBAAO,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAC7B,CAAC,KAAU,EAAE,QAA0B,EAAE,IAAS,EAAE,EAAE;oBAClD,IAAI,CAAC,KAAK,IAAI,QAAQ,CAAC,UAAU,IAAI,GAAG,EAAE;wBACtC,OAAO,EAAE,CAAC;qBACb;yBAAM;wBACH,MAAM,EAAE,CAAC;qBACZ;gBACT,CAAC,CAAC,CAAC;YACP,CAAC,CAAC,CAAC;QACP,CAAC;KAAA;;AA7Cc,YAAM,GAAG,IAAI,aAAE,CAAC,WAAW,CAAC,CAAC;AALhD,sBAmDC;AAED;IAEI,YAAmB,OAAe;QAAf,YAAO,GAAP,OAAO,CAAQ;IAElC,CAAC;CACJ","sourcesContent":["import { BlockChain, Transaction } from \"./blockchain\";\r\nimport { ec } from \"elliptic\";\r\nimport request from \"request\";\r\n\r\n//const EC = require(\"elliptic\").ec;\r\n//const ec = new EC(\"secp256k1\");\r\nexport class State {\r\n    public static chain: BlockChain;\r\n    public static neighbors: Neighbour[];\r\n    public static wallet: string;\r\n\r\n    private static keyGen = new ec(\"secp256k1\");\r\n    static myKey: ec.KeyPair;\r\n    static myWalletAddress: string;\r\n\r\n    static init(privateKey: string) {\r\n        this.chain = new BlockChain();\r\n        this.neighbors = [];\r\n        this.myKey = this.keyGen.keyFromPrivate(privateKey);\r\n        this.myWalletAddress = this.myKey.getPublic(\"hex\");\r\n    }\r\n\r\n    static sendTransaction(tx1: Transaction): void {\r\n        this.postToNeighbours(20, \"/api/add\", {\r\n            from: tx1.from,\r\n            to: tx1.to,\r\n            amount: tx1.amount,\r\n            comment: tx1.comment,\r\n            signature: tx1.signature\r\n        });\r\n    }\r\n\r\n    private static postToNeighbours(count: number, path: string, data: any) {\r\n        for (let i = 0; i < count; i++) {\r\n            if (this.neighbors.length <= i) {\r\n                console.log(\"no more neighbours: \" + path);\r\n                break;\r\n            }\r\n            \r\n            this.postToNeighbour(this.neighbors[i], path, data);\r\n        }\r\n    }\r\n\r\n    private static async postToNeighbour(n: Neighbour, path: string, data: any) {\r\n        return new Promise(function(resolve, reject){\r\n            const addr = n.address + \"/\" + path;\r\n\r\n            request.post(addr, { json: data }, \r\n                (error: any, response: request.Response, body: any) => {\r\n                    if (!error && response.statusCode == 200) {\r\n                        resolve();\r\n                    } else {\r\n                        reject();\r\n                    }\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nclass Neighbour {\r\n\r\n    constructor(public address: string) {\r\n\r\n    }\r\n}"]}